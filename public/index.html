<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P é˜…åå³ç„šå›¾ç‰‡ä¼ è¾“</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      padding: 40px;
      max-width: 600px;
      width: 100%;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 24px;
    }
    .section {
      margin-bottom: 20px;
    }
    .section h2 {
      font-size: 18px;
      margin-bottom: 10px;
      color: #555;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s;
      width: 100%;
      margin-bottom: 10px;
    }
    button:hover:not(:disabled) {
      background: #5568d3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    input[type="text"], input[type="file"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-bottom: 10px;
      font-size: 14px;
    }
    .status {
      background: #f0f0f0;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 14px;
      color: #666;
      min-height: 50px;
    }
    .room-id {
      background: #e8f4f8;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 16px;
      text-align: center;
      font-weight: bold;
      color: #2196F3;
    }
    #canvas {
      max-width: 100%;
      border: 1px solid #ddd;
      border-radius: 6px;
      display: none;
      margin: 20px auto;
    }
    .warning {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 13px;
      color: #856404;
    }
    .progress {
      width: 100%;
      height: 20px;
      background: #f0f0f0;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      display: none;
    }
    .progress-bar {
      height: 100%;
      background: #667eea;
      transition: width 0.3s;
      width: 0%;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”’ P2P é˜…åå³ç„šå›¾ç‰‡ä¼ è¾“</h1>
    
    <div class="warning">
      âš ï¸ å®‰å…¨æç¤ºï¼šæœ¬åº”ç”¨ä½¿ç”¨ç«¯åˆ°ç«¯åŠ å¯†ï¼ŒæœåŠ¡å™¨ä¸ä¿å­˜ä»»ä½•å›¾ç‰‡æˆ–å¯†é’¥ã€‚ä½†æ— æ³•é˜»æ­¢å±å¹•æˆªå›¾æˆ–ç›¸æœºæ‹ç…§ã€‚è¯·å‹¿ä¼ è¾“æåº¦æ•æ„Ÿå†…å®¹ã€‚
    </div>

    <div class="status" id="status">å‡†å¤‡å°±ç»ª</div>

    <div class="section" id="createSection">
      <h2>å‘é€ç«¯</h2>
      <button id="createBtn">åˆ›å»ºä¼šè¯</button>
      <div class="room-id" id="roomIdDisplay" style="display:none;"></div>
      <input type="file" id="fileInput" accept="image/*" style="display:none;" />
      <button id="sendBtn" style="display:none;">é€‰æ‹©å¹¶å‘é€å›¾ç‰‡</button>
    </div>

    <div class="section" id="joinSection">
      <h2>æ¥æ”¶ç«¯</h2>
      <input type="text" id="roomInput" placeholder="è¾“å…¥æˆ¿é—´ ID" />
      <button id="joinBtn">åŠ å…¥ä¼šè¯</button>
    </div>

    <div class="progress" id="progress">
      <div class="progress-bar" id="progressBar"></div>
    </div>

    <canvas id="canvas"></canvas>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let ws = null;
    let pc = null;
    let dc = null;
    let roomId = null;
    let isCreator = false;
    let ecdhKeyPair = null;
    let sharedKey = null;
    let receivedChunks = [];
    let totalChunks = 0;
    let countdown = null;
    let imageObjectUrl = null;

    // DOM å…ƒç´ 
    const status = document.getElementById('status');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const roomInput = document.getElementById('roomInput');
    const roomIdDisplay = document.getElementById('roomIdDisplay');
    const fileInput = document.getElementById('fileInput');
    const sendBtn = document.getElementById('sendBtn');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const progressDiv = document.getElementById('progress');
    const progressBar = document.getElementById('progressBar');

    // è¿æ¥ WebSocket
    function connectWS() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}`);
      
      ws.onopen = () => {
        updateStatus('å·²è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨');
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        handleSignaling(data);
      };

      ws.onerror = () => {
        updateStatus('è¿æ¥é”™è¯¯');
      };

      ws.onclose = () => {
        updateStatus('è¿æ¥å·²æ–­å¼€');
      };
    }

    // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
    async function handleSignaling(data) {
      const { type, room, payload } = data;

      if (type === 'created') {
        roomId = room;
        isCreator = true;
        roomIdDisplay.textContent = `æˆ¿é—´ ID: ${roomId}`;
        roomIdDisplay.style.display = 'block';
        updateStatus('ä¼šè¯å·²åˆ›å»ºï¼Œç­‰å¾…æ¥æ”¶ç«¯åŠ å…¥...');
        // ç”Ÿæˆ ECDH å¯†é’¥å¯¹
        await generateECDHKeyPair();
      }

      if (type === 'peer-joined') {
        updateStatus('å¯¹ç«¯å·²åŠ å…¥ï¼Œå»ºç«‹è¿æ¥...');
        if (isCreator) {
          await createPeerConnection();
          dc = pc.createDataChannel('image', { ordered: true });
          setupDataChannel();
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          sendSignaling('offer', { offer });
          // å‘é€å…¬é’¥
          sendPublicKey();
        } else {
          await createPeerConnection();
        }
      }

      if (type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(payload.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignaling('answer', { answer });
      }

      if (type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(payload.answer));
      }

      if (type === 'ice-candidate') {
        if (payload.candidate) {
          await pc.addIceCandidate(new RTCIceCandidate(payload.candidate));
        }
      }

      if (type === 'public-key') {
        // æ¥æ”¶å¯¹ç«¯å…¬é’¥å¹¶æ´¾ç”Ÿå…±äº«å¯†é’¥
        await deriveSharedKey(payload.publicKey);
        if (!isCreator) {
          // æ¥æ”¶ç«¯å‘é€è‡ªå·±çš„å…¬é’¥
          sendPublicKey();
        }
      }

      if (type === 'peer-left') {
        updateStatus('å¯¹ç«¯å·²ç¦»å¼€');
        cleanup();
      }

      if (type === 'session-ended') {
        updateStatus('ä¼šè¯å·²ç»“æŸ');
        cleanup();
      }

      if (type === 'error') {
        updateStatus(`é”™è¯¯: ${payload.message}`);
      }
    }

    // ç”Ÿæˆ ECDH å¯†é’¥å¯¹
    async function generateECDHKeyPair() {
      ecdhKeyPair = await window.crypto.subtle.generateKey(
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        ['deriveKey', 'deriveBits']
      );
    }

    // å‘é€å…¬é’¥
    async function sendPublicKey() {
      const publicKeyJwk = await window.crypto.subtle.exportKey('jwk', ecdhKeyPair.publicKey);
      sendSignaling('public-key', { publicKey: publicKeyJwk });
    }

    // æ´¾ç”Ÿå…±äº«å¯†é’¥
    async function deriveSharedKey(peerPublicKeyJwk) {
      const peerPublicKey = await window.crypto.subtle.importKey(
        'jwk',
        peerPublicKeyJwk,
        { name: 'ECDH', namedCurve: 'P-256' },
        true,
        []
      );

      sharedKey = await window.crypto.subtle.deriveKey(
        { name: 'ECDH', public: peerPublicKey },
        ecdhKeyPair.privateKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );

      updateStatus('å¯†é’¥åå•†å®Œæˆï¼Œè¿æ¥å·²åŠ å¯†');
      
      if (isCreator) {
        sendBtn.style.display = 'block';
      }
    }

    // åˆ›å»º PeerConnection
    async function createPeerConnection() {
      pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          sendSignaling('ice-candidate', { candidate: event.candidate });
        }
      };

      pc.ondatachannel = (event) => {
        dc = event.channel;
        setupDataChannel();
      };

      pc.onconnectionstatechange = () => {
        updateStatus(`è¿æ¥çŠ¶æ€: ${pc.connectionState}`);
        if (pc.connectionState === 'connected') {
          updateStatus('P2P è¿æ¥å·²å»ºç«‹');
        }
      };
    }

    // è®¾ç½® DataChannel
    function setupDataChannel() {
      dc.binaryType = 'arraybuffer';

      dc.onopen = () => {
        updateStatus('æ•°æ®é€šé“å·²æ‰“å¼€');
      };

      dc.onmessage = async (event) => {
        if (typeof event.data === 'string') {
          const meta = JSON.parse(event.data);
          if (meta.type === 'metadata') {
            totalChunks = meta.totalChunks;
            receivedChunks = [];
            progressDiv.style.display = 'block';
            updateStatus(`æ¥æ”¶ä¸­... 0/${totalChunks}`);
            // å­˜å‚¨ metadata åˆ°å…¨å±€å˜é‡
            window.imageMetadata = {
              iv: new Uint8Array(meta.iv),
              fileType: meta.fileType
            };
          }
        } else {
          receivedChunks.push(event.data);
          const percent = Math.round((receivedChunks.length / totalChunks) * 100);
          progressBar.style.width = percent + '%';
          updateStatus(`æ¥æ”¶ä¸­... ${receivedChunks.length}/${totalChunks}`);

          if (receivedChunks.length === totalChunks) {
            await handleReceivedImage();
          }
        }
      };

      dc.onclose = () => {
        updateStatus('æ•°æ®é€šé“å·²å…³é—­');
      };
    }

    // å‘é€ä¿¡ä»¤
    function sendSignaling(type, payload) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type, room: roomId, payload }));
      }
    }

    // æ›´æ–°çŠ¶æ€
    function updateStatus(msg) {
      status.textContent = msg;
    }

    // åˆ›å»ºä¼šè¯
    createBtn.addEventListener('click', async () => {
      connectWS();
      // ç­‰å¾… WebSocket è¿æ¥å°±ç»ª
      const checkConnection = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          clearInterval(checkConnection);
          ws.send(JSON.stringify({ type: 'create' }));
        }
      }, 100);
      createBtn.disabled = true;
      joinBtn.disabled = true;
    });

    // åŠ å…¥ä¼šè¯
    joinBtn.addEventListener('click', async () => {
      const room = roomInput.value.trim();
      if (!room) {
        alert('è¯·è¾“å…¥æˆ¿é—´ ID');
        return;
      }
      roomId = room;
      isCreator = false;
      connectWS();
      // ç­‰å¾… WebSocket è¿æ¥å°±ç»ª
      const checkConnection = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          clearInterval(checkConnection);
          ws.send(JSON.stringify({ type: 'join', room }));
        }
      }, 100);
      createBtn.disabled = true;
      joinBtn.disabled = true;
      // ç”Ÿæˆ ECDH å¯†é’¥å¯¹
      await generateECDHKeyPair();
    });

    // é€‰æ‹©å¹¶å‘é€å›¾ç‰‡
    sendBtn.addEventListener('click', () => {
      fileInput.click();
    });

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) return;

      updateStatus('è¯»å–å›¾ç‰‡...');
      const buffer = await file.arrayBuffer();

      updateStatus('åŠ å¯†å›¾ç‰‡...');
      const iv = window.crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await window.crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        sharedKey,
        buffer
      );

      updateStatus('å‘é€å›¾ç‰‡...');
      const CHUNK_SIZE = 16384; // 16KB
      const encryptedArray = new Uint8Array(encrypted);
      const totalChunks = Math.ceil(encryptedArray.length / CHUNK_SIZE);

      // å‘é€å…ƒæ•°æ®ï¼ˆåŒ…å« IV å’Œåˆ†ç‰‡ä¿¡æ¯ï¼‰
      dc.send(JSON.stringify({
        type: 'metadata',
        totalChunks,
        iv: Array.from(iv),
        fileType: file.type
      }));

      // åˆ†ç‰‡å‘é€
      for (let i = 0; i < totalChunks; i++) {
        const start = i * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, encryptedArray.length);
        const chunk = encryptedArray.slice(start, end);
        dc.send(chunk);
        // å°å»¶è¿Ÿé¿å…è¿‡å¿«å‘é€å¯¼è‡´ DataChannel ç¼“å†²åŒºæº¢å‡º
        await new Promise(resolve => setTimeout(resolve, 10));
      }

      updateStatus('å›¾ç‰‡å·²å‘é€');
      sendBtn.disabled = true;
      fileInput.value = '';
    });

    // å¤„ç†æ¥æ”¶åˆ°çš„å›¾ç‰‡
    async function handleReceivedImage() {
      updateStatus('è§£å¯†å›¾ç‰‡...');

      // receivedChunks åªåŒ…å«åŠ å¯†æ•°æ®åˆ†ç‰‡ï¼ˆmetadata å·²åœ¨ onmessage ä¸­å•ç‹¬å¤„ç†ï¼‰
      // ä½†æˆ‘ä»¬éœ€è¦ä»å…¨å±€å˜é‡è·å– metadata
      // è®©æˆ‘ä»¬é‡æ–°è®¾è®¡ï¼šä½¿ç”¨å…¨å±€å˜é‡å­˜å‚¨ metadata
      
      // åˆå¹¶æ‰€æœ‰åŠ å¯†æ•°æ®åˆ†ç‰‡
      let totalSize = 0;
      for (let i = 0; i < receivedChunks.length; i++) {
        totalSize += receivedChunks[i].byteLength;
      }
      const combinedEncrypted = new Uint8Array(totalSize);
      let offset = 0;
      for (let i = 0; i < receivedChunks.length; i++) {
        combinedEncrypted.set(new Uint8Array(receivedChunks[i]), offset);
        offset += receivedChunks[i].byteLength;
      }

      try {
        const decrypted = await window.crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: window.imageMetadata.iv },
          sharedKey,
          combinedEncrypted
        );

        // æ˜¾ç¤ºå›¾ç‰‡
        const blob = new Blob([decrypted], { type: window.imageMetadata.fileType || 'image/png' });
        imageObjectUrl = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          // æ·»åŠ æ°´å°
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.font = '20px Arial';
          ctx.fillText('é˜…åå³ç„š - 10ç§’åé”€æ¯', 10, 30);
          
          canvas.style.display = 'block';
          updateStatus('å›¾ç‰‡å·²æ˜¾ç¤ºï¼Œ10ç§’åè‡ªåŠ¨é”€æ¯');
          
          // å¼€å§‹å€’è®¡æ—¶
          startCountdown();
        };
        img.src = imageObjectUrl;
      } catch (e) {
        updateStatus('è§£å¯†å¤±è´¥: ' + e.message);
        console.error(e);
      }

      progressDiv.style.display = 'none';
    }

    // å¼€å§‹å€’è®¡æ—¶
    function startCountdown() {
      let seconds = 10;
      countdown = setInterval(() => {
        seconds--;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '20px Arial';
        ctx.fillText(`${seconds}ç§’åé”€æ¯`, canvas.width - 120, 30);
        
        if (seconds <= 0) {
          clearInterval(countdown);
          destroyImage();
        }
      }, 1000);
    }

    // é”€æ¯å›¾ç‰‡å¹¶æ¸…ç†
    function destroyImage() {
      // æ¸…ç©º canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.style.display = 'none';
      
      // æ’¤é”€ object URL
      if (imageObjectUrl) {
        URL.revokeObjectURL(imageObjectUrl);
        imageObjectUrl = null;
      }
      
      // æ¸…é›¶æ•æ„Ÿæ•°æ®
      // æ³¨æ„ï¼šJavaScript æ— æ³•ä¿è¯ç«‹å³é‡Šæ”¾å†…å­˜ï¼Œè¿™é‡Œå°½æœ€å¤§åŠªåŠ›
      receivedChunks = [];
      if (sharedKey) {
        // æ— æ³•ç›´æ¥æ¸…é›¶ CryptoKeyï¼Œä½†å¯ä»¥ç½®ç©ºå¼•ç”¨
        sharedKey = null;
      }
      if (ecdhKeyPair) {
        ecdhKeyPair = null;
      }
      
      updateStatus('å›¾ç‰‡å·²é”€æ¯ï¼Œä¼šè¯ç»“æŸ');
      
      // é€šçŸ¥æœåŠ¡å™¨é”€æ¯æˆ¿é—´
      sendSignaling('consumed', {});
      
      // å…³é—­è¿æ¥
      setTimeout(() => {
        cleanup();
      }, 1000);
    }

    // æ¸…ç†è¿æ¥
    function cleanup() {
      if (dc) {
        dc.close();
        dc = null;
      }
      if (pc) {
        pc.close();
        pc = null;
      }
      if (ws) {
        ws.close();
        ws = null;
      }
      if (countdown) {
        clearInterval(countdown);
        countdown = null;
      }
      // æ¸…ç†æ•æ„Ÿæ•°æ®
      receivedChunks = [];
      sharedKey = null;
      ecdhKeyPair = null;
      if (imageObjectUrl) {
        URL.revokeObjectURL(imageObjectUrl);
        imageObjectUrl = null;
      }
    }

    // é¡µé¢å¸è½½æ—¶æ¸…ç†
    window.addEventListener('beforeunload', cleanup);
  </script>
</body>
</html>
